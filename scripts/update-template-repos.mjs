#!/usr/bin/env node

/**
 * Automatic template repos update script (JavaScript version)
 *
 * This script:
 * 1. Finds all repos created from your template
 * 2. Creates Pull Requests to update them
 * 3. Notifies repo owners
 */

import { Octokit } from '@octokit/rest';

// Configuration
const config = {
  // Template information
  templateOwner: process.env.TEMPLATE_OWNER || 'koala819',
  templateRepo: process.env.TEMPLATE_REPO || 'Eduroots',

  // GitHub token (required)
  githubToken: process.env.TOKEN,

  // Branch and PR configuration
  branchName: 'update-from-template',
  prTitle: '🔄 Update from template',

  // Files to update from template
  filesToUpdate: [
    'client/components/atoms/PWAButton.tsx',
    'middleware.ts',
    'public/manifest.json',
    'app/sw.ts',
    'package.json',
  ],

  // Repos to update (manual list)
  reposToUpdate: [
    { owner: 'koala819', name: 'Eduroots_COLOMIERS', defaultBranch: 'master' },
  ],

  // Pull Request message
  prBody: `
## 🔄 Automatic update from template

This Pull Request updates your repo with the latest changes from the template.

### 📋 Included changes:
- ✅ Fixed automatic PWA installation
- ✅ Improved middleware for static files
- ✅ Performance optimizations
- ✅ Support for beforeinstallprompt event

### 🚀 Automatic PWA Installation
The \`beforeinstallprompt\` event is now properly handled to trigger native browser installation.

### 🔧 How to test:
1. Click on the "Install application" button
2. Native browser installation should trigger
3. On iOS, manual instructions are displayed

### 📝 Notes:
- This update is compatible with previous versions
- No additional configuration required
- Test in development mode with \`npm run dev\`

---

*This PR was automatically generated by the template update script.*
  `.trim(),

  // Advanced options
  options: {
    maxRepos: 100,
    requestDelay: 1000,
    debug: process.env.DEBUG === 'true',
    ignoreErrors: false,
    createIssuesForFailures: false,
  },
};

class TemplateUpdater {
  constructor() {
    if (!config.githubToken) {
      throw new Error('TOKEN environment variable is required');
    }

    this.config = config;
    this.octokit = new Octokit({
      auth: config.githubToken,
    });
  }

  async findTemplateForks() {
    console.log('🔍 Getting repos from manual configuration...');

    try {
      const repos = [];

      for (const repoConfig of this.config.reposToUpdate) {
        try {
          const { data: repo } = await this.octokit.repos.get({
            owner: repoConfig.owner,
            repo: repoConfig.name,
          });
          repos.push(repo);
        } catch (error) {
          if (error.status === 404) {
            console.log(`⚠️  Repo ${repoConfig.owner}/${repoConfig.name} not found`);
          } else {
            console.error(`❌ Error accessing ${repoConfig.owner}/${repoConfig.name}:`, error.message);
          }
        }
      }

      console.log(`✅ Found ${repos.length} repos from configuration`);
      return repos;
    } catch (error) {
      console.error('❌ Error getting repos:', error.message);
      return [];
    }
  }

  async createUpdateBranch(owner, repo) {
    try {
      // Get main branch
      const { data: mainBranch } = await this.octokit.repos.getBranch({
        owner,
        repo,
        branch: 'master',
      });

      // Create new branch
      await this.octokit.git.createRef({
        owner,
        repo,
        ref: `refs/heads/${this.config.branchName}`,
        sha: mainBranch.commit.sha,
      });

      console.log(`✅ Branch ${this.config.branchName} created for ${owner}/${repo}`);
      return true;
    } catch (error) {
      if (error.status === 422) {
        console.log(`⚠️  Branch ${this.config.branchName} already exists for ${owner}/${repo}`);
        return true;
      }
      console.error(`❌ Error creating branch for ${owner}/${repo}:`, error.message);
      return false;
    }
  }

  async updateFiles(owner, repo) {
    try {
      // Update files in repo
      for (const filePath of this.config.filesToUpdate) {
        await this.updateFile(owner, repo, filePath);

        // Delay between requests to avoid rate limits
        if (this.config.options.requestDelay > 0) {
          await new Promise((resolve) => setTimeout(resolve, this.config.options.requestDelay));
        }
      }

      console.log(`✅ Files updated for ${owner}/${repo}`);
      return true;
    } catch (error) {
      console.error(`❌ Error updating files for ${owner}/${repo}:`, error.message);
      return false;
    }
  }

  async updateFile(owner, repo, filePath) {
    try {
      // Get file content from template
      const { data: templateFile } = await this.octokit.repos.getContent({
        owner: this.config.templateOwner,
        repo: this.config.templateRepo,
        path: filePath,
        ref: 'master',
      });

      // Get current file content in repo
      const { data: currentFile } = await this.octokit.repos.getContent({
        owner,
        repo,
        path: filePath,
        ref: this.config.branchName,
      });

      // Compare contents
      if (templateFile.sha !== currentFile.sha) {
        // Update file
        await this.octokit.repos.createOrUpdateFileContents({
          owner,
          repo,
          path: filePath,
          message: `🔄 Update ${filePath} from template`,
          content: templateFile.content,
          sha: currentFile.sha,
          branch: this.config.branchName,
        });

        console.log(`  📝 ${filePath} updated`);
      } else {
        console.log(`  ✅ ${filePath} already up to date`);
      }
    } catch (error) {
      if (error.status === 404) {
        console.log(`  ⚠️  ${filePath} doesn't exist in repo`);
      } else {
        console.error(`  ❌ Error updating ${filePath}:`, error.message);
      }
    }
  }

  async createPullRequest(owner, repo) {
    try {
      const { data: pr } = await this.octokit.pulls.create({
        owner,
        repo,
        title: this.config.prTitle,
        body: this.config.prBody,
        head: this.config.branchName,
        base: 'master',
      });

      console.log(`✅ Pull Request created: ${pr.html_url}`);
      return pr.html_url;
    } catch (error) {
      if (error.status === 422) {
        console.log(`⚠️  Pull Request already exists for ${owner}/${repo}`);
        return null;
      }
      console.error(`❌ Error creating PR for ${owner}/${repo}:`, error.message);
      return null;
    }
  }

  async updateRepo(owner, repo) {
    console.log(`\n🔄 Updating ${owner}/${repo}...`);

    try {
      // 1. Create update branch
      const branchCreated = await this.createUpdateBranch(owner, repo);
      if (!branchCreated) {
        return {
          repo: `${owner}/${repo}`,
          prUrl: null,
          success: false,
          error: 'Failed to create branch',
        };
      }

      // 2. Update files
      const filesUpdated = await this.updateFiles(owner, repo);
      if (!filesUpdated) {
        return {
          repo: `${owner}/${repo}`,
          prUrl: null,
          success: false,
          error: 'Failed to update files',
        };
      }

      // 3. Create Pull Request
      const prUrl = await this.createPullRequest(owner, repo);

      return {
        repo: `${owner}/${repo}`,
        prUrl,
        success: true,
      };
    } catch (error) {
      return {
        repo: `${owner}/${repo}`,
        prUrl: null,
        success: false,
        error: error.message,
      };
    }
  }

  async run() {
    console.log('🚀 Starting template repos update...');
    console.log(`📋 Template: ${this.config.templateOwner}/${this.config.templateRepo}`);
    console.log(`🔑 Token configured: ${!!this.config.githubToken}`);

    try {
      // Get repos to update
      const repos = await this.findTemplateForks();
      if (repos.length === 0) {
        console.log('❌ No repos found to update');
        return;
      }

      // Update each repo
      const results = [];
      for (const repo of repos) {
        const result = await this.updateRepo(repo.owner.login, repo.name);
        results.push(result);

        // Delay between repos
        if (this.config.options.requestDelay > 0) {
          await new Promise((resolve) => setTimeout(resolve, this.config.options.requestDelay));
        }
      }

      // Display summary
      this.displaySummary(results);
    } catch (error) {
      console.error('❌ Error running update:', error.message);
      process.exit(1);
    }
  }

  displaySummary(results) {
    console.log('\n📊 Update Summary:');
    console.log('================');

    const successful = results.filter(r => r.success);
    const failed = results.filter(r => !r.success);

    console.log(`✅ Successful: ${successful.length}`);
    successful.forEach(result => {
      console.log(`  - ${result.repo}: ${result.prUrl || 'No PR created'}`);
    });

    if (failed.length > 0) {
      console.log(`❌ Failed: ${failed.length}`);
      failed.forEach(result => {
        console.log(`  - ${result.repo}: ${result.error}`);
      });
    }

    console.log(`\n🎉 Update completed! ${successful.length}/${results.length} repos updated successfully.`);
  }
}

// Run the script
async function main() {
  try {
    const updater = new TemplateUpdater();
    await updater.run();
  } catch (error) {
    console.error('❌ Fatal error:', error.message);
    process.exit(1);
  }
}

main();
